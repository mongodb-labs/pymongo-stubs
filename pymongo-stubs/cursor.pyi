from typing import Any, Dict, List, Mapping, Optional, Sequence, Tuple, Union

from pymongo.client_session import ClientSession
from pymongo.collation import Collation
from pymongo.collection import Collection
from pymongo.pool import Pool, SocketInfo

class CursorType:
    NON_TAILABLE: int = ...
    TAILABLE: Any = ...
    TAILABLE_AWAIT: Any = ...
    EXHAUST: Any = ...

class _SocketManager:
    sock: Any = ...
    pool: Any = ...
    def __init__(self, sock: SocketInfo, pool: Pool) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...

class Cursor:
    def __init__(
        self,
        collection: Any,
        filter: Optional[Any] = ...,
        projection: Optional[Any] = ...,
        skip: int = ...,
        limit: int = ...,
        no_cursor_timeout: bool = ...,
        cursor_type: Any = ...,
        sort: Optional[Any] = ...,
        allow_partial_results: bool = ...,
        oplog_replay: bool = ...,
        modifiers: Optional[Any] = ...,
        batch_size: int = ...,
        manipulate: bool = ...,
        collation: Optional[Any] = ...,
        hint: Optional[Any] = ...,
        max_scan: Optional[Any] = ...,
        max_time_ms: Optional[Any] = ...,
        max: Optional[Any] = ...,
        min: Optional[Any] = ...,
        return_key: bool = ...,
        show_record_id: bool = ...,
        snapshot: bool = ...,
        comment: Optional[Any] = ...,
        session: Optional[ClientSession] = ...,
        allow_disk_use: Optional[Any] = ...,
    ) -> None: ...
    @property
    def collection(self) -> Collection: ...
    @property
    def retrieved(self) -> int: ...
    def __del__(self) -> None: ...
    def rewind(self) -> Cursor: ...
    def clone(self) -> Cursor: ...
    def close(self) -> None: ...
    def add_option(self, mask: int) -> Cursor: ...
    def remove_option(self, mask: int) -> Cursor: ...
    def allow_disk_use(self, allow_disk_use: Any): ...
    def limit(self, limit: int) -> Cursor: ...
    def batch_size(self, batch_size: int) -> Cursor: ...
    def skip(self, skip: int) -> Cursor: ...
    def max_time_ms(self, max_time_ms: int) -> Cursor: ...
    def max_await_time_ms(self, max_await_time_ms: int) -> Cursor: ...
    def __getitem__(self, index: Any): ...
    def max_scan(self, max_scan: int) -> Cursor: ...
    def max(self, spec: Sequence[Tuple[str, int]]) -> Cursor: ...
    def min(self, spec: Sequence[Tuple[str, int]]) -> Cursor: ...
    def sort(
        self, key_or_list: Union[str, Sequence[Tuple[str, Union[int, str]]]], direction: Optional[Union[int, str]] = ...
    ) -> Cursor: ...
    def count(self, with_limit_and_skip: bool = ...) -> int: ...
    def distinct(self, key: str) -> List[Any]: ...
    def explain(self) -> Dict[str, Any]: ...
    def hint(self, index: Union[str, Tuple[str, Union[int, str]]]) -> Cursor: ...
    def comment(self, comment: Union[str, Mapping[str, Any]]) -> Cursor: ...
    def where(self, code: str) -> Cursor: ...
    def collation(self, collation: Collation) -> Cursor: ...
    @property
    def alive(self) -> bool: ...
    @property
    def cursor_id(self) -> int: ...
    @property
    def address(self) -> Tuple[str, int]: ...
    @property
    def session(self): ...
    def __iter__(self) -> Any: ...
    def next(self) -> Dict[str, Any]: ...
    __next__: Any = ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __copy__(self): ...
    def __deepcopy__(self, memo: Any): ...

class RawBatchCursor(Cursor):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def explain(self): ...
    def __getitem__(self, index: Any) -> None: ...
